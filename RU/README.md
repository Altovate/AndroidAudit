**Ваше Android-приложение как сцена преступления**

Технический аудит iOS и Android приложений стали неотъемлемой частью нашей повседневной работы в Karumi. Хоть это и выглядит просто, имеется немало деталей реализации для рассмотрения при проведении такой проверки. В этом документе мы рассмотрим то, что мы считаем наиболее важным для проверки и разделим это по техническим областям.

**Система контроля версий:**

Используется ли система контроля версий, какая система и как рабочие процессы организованы - это многое расскажет о процессе разработки.

*   Есть ли у вас правильно настроенный *ignore файл, чтобы мета файлы IDE и другие посторонние элементы не попадали в хранилище?

*   Сторонние библиотеки сконфигурированы в качестве внешних зависимостей, а не лежат в хранилище?

*   Достаточно ли краткие коментарии к коммитам (прим. пер. commit - изменение) вы используете?

*   Правильный ли размер у ваших коммитов?

*   Все ли файлы в коммите связанны с одной и той же проблемой или функцией?

*   Используете ли вы какие-либо схемы ветвления типа "feature branch" или "git-flow"?

*   Достаточно ли информативны названия веток?

*   Используете ли вы систему pull request/code review до слияния кода в master?

    *   Есть ли у вас какие-либо рекомендации относительно того, на что нужно обращать внимание при рассмотрении PR?

    *   Сколько комментариев в среднем для каждого PR?

    *   Сколько людей рассматривает каждый PR?

    *   Сколько +1 вам нужно для слияния?

    *   Кто несет ответственность за закрытие ветки?

*   Вы используете release branches для каждого релиза?

*   Как долго открыт процесс подготовки (staging process)?

*   Сколько исправлений вы вносите в release candidate, прежде чем выпустить его?

*   Имеется ли возможность переключиться на точный код какой-либо из опубликованных версий вашего приложения?

*   Сколько исправлений (hotfix) вы выпустили в прошлом году?

*   Вы сплющиваете (squashing) комиты до слияния (merging) его в master/develop ветку?

*   Готовы ли master/develop ветки к выпуску в любое время?

**Инструменты сборки:**

Определяющим фактором является возможность запустить процесс сборки на машине разработчика и на любой другой внешней системе, например на системе непрерывной сборки (continuous integration).

*   Сколько библиотек используются в проекте?

*   Разделен ли проект на модули?

*   Используются зависимости Maven или Gradle или локальные .jar-файлы?

*   На опасное ли расстояние приближен проект к лимиту количества методов в .dex файлах? Или уже за гранью?

*   Вы используете библиотеки, которые не нужны в проекте?

*   Используется ли multidex?

*   Все ли внешние зависимости обновлены до современных версий?

*   Все ли лицензии сторонних библиотек соблюдены?

*   Используются ли устаревшие или не поддерживаемые сторонние библиотеки?

*   Минимальный SDK обусловлен требованием Технического Задания (product description)?

*   Актуален ли целевой SDK (target SDK)?

*   Используется ли ProGuard, или любой другой инструмент обфускации (obfuscation - запутывание), включен и настроен правильно?

*   Учетные данные хранилища ключей (keystore credentials) и учетные данные Google Play хранятся в надежном месте?

*   Хранилище ключей приложения (application keystore) и учетные данные хранятся в надежном месте?

*   Должным ли образом настроены build types?

*   Правильно ли используются flavors?

*   Правильно ли настроен релизный тип сборки?

*   Включена ли опция резервного копирования?

*   Lint включен и успешно работает?

*   Имеется ли инструмент статического анализа, настроен и работает?

*   Есть ли Checkstyle, настроен и работает?

*   Правильно ли настроен id и version name/code?

*   Вы используете какую-либо структуру или стратегию версионирования id?

*   Используется ли инструмент непрерывной сборки (continous integration), правильно ли настроен?

*   Автоматизирован ли процесс выпуска новых версий?

**Использование Android ресурсов:**

Существует широкий спектр устройств в мире Android, каждый из них со своим собственным размером экрана, возможностями и т.д. Вам нужно быть очень внимательными и осторожно использовать некоторые из Android инструментов, чтобы обеспечить наилучший опыт для ваших пользователей независимо от их устройства.

*   Существуют ли какие-либо недостающие ресурсы для densities, flavors и build types?

*   Требуется ли поддержка приложением экранов с различной плотностью пикселей (density) по техническому заданию?

*   Используются ли в приложении drawable/mipmap, шрифты или векторные ресурсы?

*   Существуют ли какие-либо недостающие переводы?

*   Автоматизирован ли процесс перевода?

*   Какой язык выбран по умолчанию для перевода?

*   Использует ли приложение сторонние шрифты?

*   Использует ли приложение значения конфигурации внутри файла строковых ресурсов?

*   Соблюдается ли соглашение для присвоения однородных имен ресурсам?

*   Есть ли параметры конфигурации, связанные с аппаратными средствами устройства, правильно ли настроены?

*   Поддерживаются ли планшеты?

**Использование Android Layout :**

Как мы уже говорили ранее, существует широкий спектр Android устройств в мире, каждый из них с собственным размером и плотностью экрана. Определяющим фактором является правильное использование Android Layouts.

*   Возникают ли проблемы с производительностью из-за количество слоев в макетах (layouts) приложения?

*   Используете ли вы темы и стили?

*   Используются ли повторно макеты (layouts) с использованием "include" тега?

*   Вы используете правильный тип группировок в макетах?

*   Учтены ли различные размеры экранов в макетах?

*   Используется ли соглашение об именах, чтобы присваиваемые имена макетам и виджетам оставались однородными?

*   Списки реализованы с использованием ListView или RecyclerView?

*   Android Support Library правильно используется?

**Права доступа:**

Уточнение возможных действий (permissions) создает доверительные отношения среди пользователей и помогает вашему приложению избегать ненужные проблемы и взаимодействовать с другими сервисами чтобы обеспечить необходимый опыт пользователям.

*   Все ли запрашиваемые разрешения (permissions) действительно необходимы?

*   Разрешение используется намеренно?

*   Есть ли отсутствующие разрешения?

*   Если целевой SDK больше, чем 23\. то "опасные разрешения" запрашиваются с помощью системы разрешений совместимости (compatibility permissions system)?

*   Разрешение запрашиваются тогда, когда они будут использоваться?

*   Есть ли обратная связь с пользователем, объясняющая, почему разрешение необходимо?

**Проблемы с безопасностью:**

Как разработчики, мы должны сознательно относиться к безопасности наших приложений, мы не хотим, чтобы данные наших пользователей утекли или их сессии были украдены.

*   Настроен ли HTTP клиент на использование HTTPS?

*   Настроен ли HTTP клиент, чтобы использовать сертификат пиннинга и сообщения аутентификации с HMAC?

*   Приложение сохраняет приватную информацию пользователя? Где?

*   Приложение сохраняет информацию вне внутренней системы хранения данных?

*   Логируется(logging traces) ли приложение в релизной сборке?

*   Обфусцирован(obfuscated) ли код приложения?

*   Предоставляет ли приложение провайдера контента (content provider), приемника (receiver) или сервис другим приложениям?

*   отключено ли "debuggable" значение приложения в релизной сборке?

**Push уведомление (Push Notifications):**

Push это отличный механизм, который показывает нашим пользователям информацию в любое время, но это более сложная проблема, чем кажется на первый взгляд.

*   Используюется ли сторонняя библиотека для реализации системы Push-уведомлений?

*   Система GCM используется для передачи информации приложению или просто, чтобы показать сообщений пользователю?

*   Как ведет себя приложение при получении Push-уведомления?

*   Как ведет себя приложение, когда связанная с Push-уведомлением информация не ожидалась?

*   Уведомления показываются пользователю с помощью совместимости (compatibility) API ?

**Производительность:**

Производительность имеет решающее значение. Никто не хочет использовать на своих устройствах медленное приложение за 400-600$. Производительность это $.

*   Есть ли в приложении какие-либо утечки памяти?

*   Настроен ли любой анализатор памяти, как "LeakCanary" в develop сборке?

*   Android Strict Mode подключен и настроен в develop сборке?

*   Как используются thread в приложении? Вы используете async tasks, intent services или любые другие сторонние библиотеки?

*   Число фоновых потоков вызывает проблемы с производительностью?

*   Используете ли вы какие-либо политики планировщика (scheduler policy) или просто создаются потоки по требованию?

*   Поддерживаете ли вы Android Doze Mode?

*   Прослушиваются ли события, связанные с состоянием сети или любого другого повторяющегося события от операционной системы?

*   Основной поток используется только для выполнения задач, связанных с кодом пользовательского интерфейса?

*   Имеется ли в приложении какие-либо политики кэширования?

*   Настроен ли клиент HTTP на использование тайм-аут?

*   Настроен ли клиент HTTP на использование GZIP?

*   Пользовательский интерфейс приложения работает со скоростью 60 кадров в секунду?

*   В реализации custom view выделяется большой объем памяти или выполняются дорогостоящие задачи в потоке пользовательского интерфейса (UI thread)?

*   Вы тестируете ваше приложение на lower-end (бюджетных, не производительных) устройствах?

*   Прокрутка recycler view вялая?

*   Для загрузки изображений используется какая-либо сторонняя библиотека или у вас есть своё собственное решение?

*   Изображения масштабируются под размера экрана или сразу загружаются под определенный экран устройства?

*   Использование памяти разумно?

*   "Static" Java модификатор используется правильно?

*   Любая задача, связанная с управлением загрузки изображений, обрабатывает более одного изображения за одно и тоже время?

*   Система статистики работает в фоновом потоке и сконфигурирована с правильным приоритетом?

*   Оптимизируется ли код в релизной сборки?

**Структура Java Packages:**

Хорошая структура пакетов сделает наш код более масштабируемым

*   Пакеты используются для разделения кода по features (особенностям) или концептам? Например Login vs User

*   Java модификаторы видимости используются, чтобы скрыть детали реализации внутри пакетов?

*   Все пакеты выходят из корневого пакета?

*   Директория с тестами повторяет структуру исходной папки?

*   Фичи (feature - особенности) организованы с помощью одной и той же структуры пакетов?

*   Классы лежат в правильном пакете?

*   Соблюдаются ли соглашения об однородном названии пакетов?

*   Название корневого пакета связаны с именем компании?

**Codestyle:**

Согласованная кодовая база с точки зрения стиля помогает нашим инженерам читать код проще. Инженер читает ГОРАЗДО больше кода, чем он / она пишет, так что это важное понятие

*   Является ли codestyle однородным?

*   Используете ли вы венгерскую нотацию?

*   Есть ли какой-либо инструмент Checkstyle? Он настроен и работает?

*   Придерживается ли Java codestyle?

*   Повсеместно ли используются табы или пробелы?

*   Классы названы правильно?

*   Вы используете "I" в качестве интерфейсов префикса или "Impl" как суффиксы реализации?

*   Используете ли вы правильные имена переменных?

*   Используете ли вы правильные имена для полей?

*   Используете ли вы правильные имена для методов?

*   Атрибуты и модификаторы видимости методов используются должным образом?

*   Код на английском языке?

*   Используете ли вы Javadoc?

*   Вы пишете комментарии кода?

*   Используете ли вы константы или перечисления (enums), чтобы избежать дублированных литералов?

**Offline Реализация:**

Обеспечение хорошего offline-опытa является особым фактором для наших приложений.

*   Может ли приложение использоваться, когда нет подключения к сети Интернет?

*   Каково поведение приложения при медленном сетевом соединении?

*   Какое поведение приложения при потере запроса из-за сбоя в сети?

*   Изменения данных приложения синхронизируются с бэкэндом приложения после того как соединение было восстановлено?

*   Настроен ли тайм-аут на сетевое соединение?

*   Политика кэширования HTTP настроена?

*   Сеанс пользователя восстанавливается автоматически?

**Архитектура:**

Архитектура приложений, с точки зрения кода, является одной из частей аудита, которая дает нам более глубокое представление о приложении. В ходе обзора архитектуры приложения мы будем сосредоточены на понятиях, связанных с S.O.L.I.D и Clean Code принципами.

**Presentation Layer Implementation (Реализация уровня представления):**

*   Используется любой паттерн, связанный с реализацией GUI (графического интерфейса пользователя) в приложении? Model View Presenter или Model View ViewModel два из наиболее часто используемых шаблонов для разработки приложений. Правильно ли они реализованы?

*   Presentation layer (Уровень реализации представления) связан с view implementation (реализацией вида)?

*   Связана ли view implementation (реализация вида) c model implementation (реализация модели)?

*   Реализует ли presentation layer (уровень представления) бизнес-требования?

*   Используется ли view implementation (реализация вида) относительно Android SDK tools правильно?

*   Используете ли вы сторонние библиотеки для упрощения реализации вида?

*   Правильно ли реализованы различные функции в различных activity или fragment?

*   Общее поведение пользовательского интерфейса централизовано?

*   Вы используете custom views для повторного использования кода пользовательского интерфейса?

**Domain Implementation (Реализация предметной области):**

*   Есть ли domain layer (слой предметной области) или вся бизнес-логика реализована в presentation layer (слой представления)?

*   Правила домена и различные прикладные требования выражены в основных объектах бизнес-логики?

*   реализован ли domain layer (слой предметной области) с использованием объектно-ориентированных принципов?

*   Имеются ли связи у domain layer (слой предметной области) с Android SDK или с любой сторонней библиотекой?

*   Domain layer соединен с presentation layer?

*   Domain model (модели предметной области) анемичная?

*   Используете ли вы "толстые" domain models (модели предметной области)?

*   Действительно ли код основан на низких двойных и высоких связных компонентах?

*   Обработка ошибок реализована с использованием исключений или каким-либо другим механизмом ошибок?

*   Сопоставляются ли данные между различными слоями?

*   Компоненты конструкций внешнего дизайна (например, схемы базы данных или парсинг JSON), влияют на модели предметной области?

*   Разработчики злоупотребляют наследованием?

*   Дублируется ли код?

*   Есть ли dependency injection библиотеки или сконфигурированный service locator?

*   Сложность классов/методов слишком высока?

**Реализация API:**

*   Реализация API соответствует Android SDK.

*   API клиент содержит детали реализации, связанные с клиентом HTTP или используется библиотека для реализации сетевого слоя?

*   API клиент посылает правильные заголовки?

*   Каково поведение API клиента для различных ответов HTTP?

*   API клиента реализует механизм аутентификации?

*   Правильно ли реализован процесс возобновления сеанса?

*   Есть ли поддержка JSON обфускации?

*   Действительно ли клиентская реализация API различна для различных клиентов?

**Реализация Хранения:**

*   Где хранится информация?

*   Вы читаете/пишете данные от/в место хранения, используя операции?

*   Надежно ли хранение конфиденциальной информации пользователя?

*   Слой хранения реализован с помощью какой-либо сторонней библиотеки?

*   Утекают ли детали реализации через слой хранения?

*   Правильно спроектированы tables/schemas?

*   Запросы, отправленные в хранилище, оптимизированы?

*   Android SDK API используется для хранения данных в нужном месте? Данные в базе данных или небольшие данные в Shared Preferences и файлы на диске?

**Тестируемость:**

*   Есть ли у приложения тесты?

*   Является ли приложение тестируемым?

*   В приложении используются различные (unit/integration/end-to-end) тесты?

*   Тесты правильно называнны?

*   Достаточно ли тесты охватывают проект?

*   Есть ли overspecification (чрезмерное документирование) в тестах?

*   Время выполнения разумно?

*   Покрытие кода слишком низко?

*   Существуют ли какие-либо игнорируемые тесты?

*   Есть ли нестабильные тесты (flaky tests)?

*   Используете ли вы современные фреймворки для тестирования?

*   Существуют ли какие-либо тесты без утверждений (tests without asserts?

*   Тесты и продакшен код написаны одними и теми же разработчиками?

*   У вас есть команда QA?

*   У вас есть команда QA, автоматизирующая часть тестов?

*   Есть ли у вас какие-либо системы непрерывной интеграции (continuous integration system)?

*   Используете ли вы builders, factories или mothers , чтобы уменьшить усилие, необходимое для создания некоторых объектов, которые просто необходимы для тестов?

*   Тесты утверждений (assertions) правильно написаны?

*   Проводите ли вы более одного логического утверждения на тест?

*   У вас есть различные наборы тестов, связанных с тем же проектом?

*   Вы используете различные подходы тестирования для тестирования различных частей приложения?

*   Используете ли вы какой-либо monkeyrunner?

*   Следуете ли вы какой-либо TDD или BDD методологии ?

*   Используете ли вы Java, чтобы написать test cases (тестовые случаи)?

На основании этого списка, связанного с различными темами, мы можем оценить качество приложения. Есть и другие моменты, которые мы также рассматриваем, но этот список содержит наиболее важные из них. Вы даете корректные ответы на все эти вопросы?

***Автор: Pedro Vicente Gómez Sánchez.***

